# v1.0.0 - v1.0.2

### Table of Contents
- [Encrypt](#encrypt)
- [Decrypt](#decrypt)
- [Notes](#notes)

<br>

## Encrypt

1. Make sure it’s a valid string.
2. Convert to ascii numbers (based on normal alphabet).
3. Generate random offset (0 - 93).
4. Use the offset to reset the ascii table. Offset of 0 changes nothing, offset of 3 adds 3 to all ascii numbers (33 - 126).
5. Generate a random OTP from 5 to 25 chars long. Do this by picking random ascii numbers and using the corresponding char. This is from a normal ascii table, not the one made in step 3.
6. Go through a loop and add each OTP value to the string the user wants to encrypt. ex:

  String to encrypt (ascii): 32 98 120

  Key (ascii): 45 38

  45+32 38+98 45+120 = 77 136mod(ascii max+1) 165mod(ascii max+1) = 77 42 71

7. Convert ascii back to symbols using the offset alphabet.

Final string: [ck version ############][offset - ##][OPT length - ##][OTP][encrypted string]

Ex.
- CK v3.21.4 = 0003.0021.0004
- Offset 6 = 06
- OTP jd38*i3j#9ne = length 12
- Encrypted string = ki4nn4n4kj8do834uHdh44d

0003002100040612jd38*i3j#9neki4nn4n4kj8do834uHdh44d

<br>

## Decrypt

1. Make sure it’s a valid string.
2. Separate the string into its chunks.
3. Create the alphabet based on offset.
4. Convert ciphertext to ascii based on offset alphabet and OTP based on normal alphabet.
5. Subtract the OPT from the ciphertext. ex:

  Ciphertext (ascii): 77 42 71

  OTP (ascii): 45 38

  77-45 42-38 71-45 = 32 4mod(magic) 26mod(magic) = 32 98 120

6. Convert ascii to symbols.

<br>

## Notes

- OTP is always converted using regular alphabet. The offset alphabet only gets applied to the message.
- Use 0 - 93 for ascii math and then add 33 to everything at the end.
