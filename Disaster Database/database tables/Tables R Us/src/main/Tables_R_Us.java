package main;

import java.util.ArrayList;
import java.util.List;

import entities.*;
import utils.CSV_Reader;
import utils.Country_Boundries;
import utils.Tools;

/**
 * <p>
 * This class is used to create tables based on the data generated by DisGen,
 * RelGen, and Pseudotude. These will be what the database looks like. This
 * program will create .csv files that mirror the database. These tables are
 * meant to be used for my CMSC 508 semester project and are not necessarily 
 * real data.
 * </p>
 * 
 * <p>
 * To use this program, make sure you have all of the data files that are under
 * "data used in database" on GitHub, "real_supply-items_data.csv", and
 * "mixed_location_data.csv" in your "src" folder. Once you have all the files
 * you need, run this file in the command prompt/terminal. After it runs, it
 * will have generated a .csv file for each relation in the normalized
 * relational schema.
 * </p>
 * 
 * @author Christian Babin
 * @version 1.0.0
 */
public class Tables_R_Us {
	
	// all of the disaster data files
	private static final String[] DISASTER_DATA = {
			"filler_hurricane_data.csv",
			"filler_plane-crash_data.csv",
			"filler_tornado_data.csv",
			"filler_vehicle-crash_data.csv"
	};

	// the relief campaign data file
	private static final String CAMPAIGN_DATA = "filler_relief-campaign_data.csv";
	
	// all possible items data file
	private static final String ITEM_DATA = "real_supply-items_data.csv";
	
	// the relief supplies data file
	private static final String SUPPLY_DATA = "filler_relief-supply_data.csv";
	
	// the relief agencies data file
	private static final String AGENCY_DATA = "real_relief-agency_data.csv";
	
	// the city data
	private static final String CITY_DATA = "mixed_location_data.csv";
	
	// the id prefixes for each disaster
	private static final String HURRICANE = "H-";
	private static final String PLANE_CRASH = "PC-";
	private static final String TORNADO = "T-";
	private static final String VEHICLE_CRASH = "VC-";
	
	// output file names
	private static final String DISASTER = "Disaster.csv";
	private static final String DISASTER_PATH = "DisasterPath.csv";
	private static final String EXACT_LOCATION = "ExactLocation.csv";
	private static final String IMPACT_REPORT = "ImpactReport.csv";
	private static final String ITEMS_SUPPLIED = "ItemsSupplied.csv";
	private static final String LOCATION_POPULATION = "LocationPopulation.csv";
	private static final String RELIEF_AGENCY = "ReliefAgency.csv";
	private static final String RELIEF_CAMPAIGN = "ReliefCampaign.csv";
	private static final String RELIEF_ITEM = "ReliefItem.csv";
	
	// lists of all of the entities
	private static ArrayList<ArrayList<Disaster>> disasters; // all of the disasters sorted into array lists based on disaster type
	private static ArrayList<Campaign> campaigns; // all of the relief campaigns
	private static ArrayList<Item> items; // all of the items possible to use in relief campaigns
	private static ArrayList<SupplyItem> supplyItems; // all of the items actually supplied in relief campaigns
	private static ArrayList<Agency> agencies; // all of the relief agencies
	private static ArrayList<ArrayList<Location>> locations; // all of the cites and their information sorted by country
	
	public static void main(String[] args) {
		
		// initialize array lists
		disasters = new ArrayList<>();
		campaigns = new ArrayList<>();
		items = new ArrayList<>();
		supplyItems = new ArrayList<>();
		agencies = new ArrayList<>();
		locations = new ArrayList<>();
		
		// read in everything
		readFiles();
		
		// produce output files
		genCSVFiles();

	}
	
	/**
	 * This method reads in all of the files and makes their objects.
	 */
	private static void readFiles() {
		
		// read all of the disaster files
		readDisFiles();
		
		// read the campaign data
		readCampFile();
		
		// read the item data
		readItemFile();
		
		// read the supply data
		readSupplyFile();
		
		// read the agency data
		readAgencyFile();
		
		// read the city data
		readCityFile();
		
	}
	
	/**
	 * This method reads in all of the disaster files and makes their objects.
	 */
	private static void readDisFiles() {
		
		// loop through each disaster file
		for(String file : DISASTER_DATA) {
			
			// the list of each line of the .csv file
			ArrayList<List<String>> allLines = CSV_Reader.read(file);
			
			allLines.remove(0); // get rid of the header row
			
			// figure out what we are reading
			if(file.contains("hurricane")) {
				makeHurricaneObjects(allLines);
			} else if(file.contains("plane-crash")) {
				makePlaneCrashObjects(allLines);
			} else if(file.contains("tornado")) {
				makeTornadoObjects(allLines);
			} else if(file.contains("vehicle-crash")) {
				makeVehicleCrashObjects(allLines);
			} else {
				throw new IllegalStateException("ERROR: \"" + file + "\" does not have an object class for its elements!");
			}
		}
		
	}
	
	/**
	 * This method goes through the hurricane data and makes an object for each one.
	 * 
	 * @param allLines - All of the hurricane data
	 */
	private static void makeHurricaneObjects(ArrayList<List<String>> allLines) {
		
		ArrayList<Disaster> hurricanes = new ArrayList<>();
		
		// loop through each data entry
		Hurricane newHurricane;
		for(List<String> hurricane : allLines) {
			newHurricane = new Hurricane(hurricane.get(0), Integer.parseInt(hurricane.get(1)), Integer.parseInt(hurricane.get(2)), Integer.parseInt(hurricane.get(3)), Integer.parseInt(hurricane.get(4)), Integer.parseInt(hurricane.get(5)), hurricane.get(6), hurricane.get(7), hurricane.get(8), Tools.pathBreaker(hurricane.get(9)), Double.parseDouble(hurricane.get(10)), Integer.parseInt(hurricane.get(11)), Integer.parseInt(hurricane.get(12)), Integer.parseInt(hurricane.get(13)), Integer.parseInt(hurricane.get(14)));
		
			hurricanes.add(newHurricane);
		}
		
		disasters.add(hurricanes);
		
	}
	
	/**
	 * This method goes through the plane crash data and makes an object for each
	 * one.
	 * 
	 * @param allLines - All of the plane crash data
	 */
	private static void makePlaneCrashObjects(ArrayList<List<String>> allLines) {
		
		ArrayList<Disaster> planeCrashes = new ArrayList<>();
		
		// loop through each data entry
		Plane_Crash newPlaneCrash;
		for(List<String> planeCrash : allLines) {
			newPlaneCrash = new Plane_Crash(planeCrash.get(0), planeCrash.get(1), Integer.parseInt(planeCrash.get(2)), Integer.parseInt(planeCrash.get(3)), Integer.parseInt(planeCrash.get(4)), Integer.parseInt(planeCrash.get(5)), planeCrash.get(6), Tools.locationBreaker(planeCrash.get(7)), planeCrash.get(8), planeCrash.get(9));
		
			planeCrashes.add(newPlaneCrash);
		}
		
		disasters.add(planeCrashes);
		
	}
	
	/**
	 * This method goes through the tornado data and makes an object for each one.
	 * 
	 * @param allLines - All of the tornado data
	 */
	private static void makeTornadoObjects(ArrayList<List<String>> allLines) {
		
		ArrayList<Disaster> tornados = new ArrayList<>();
		
		// loop through each data entry
		Tornado newTornado;
		for(List<String> tornado : allLines) {
			newTornado = new Tornado(tornado.get(0), Integer.parseInt(tornado.get(1)), Integer.parseInt(tornado.get(2)), Integer.parseInt(tornado.get(3)), tornado.get(4), tornado.get(5), tornado.get(6), Tools.pathBreaker(tornado.get(7)), Double.parseDouble(tornado.get(8)), Integer.parseInt(tornado.get(9)), Integer.parseInt(tornado.get(10)), Integer.parseInt(tornado.get(11)), Integer.parseInt(tornado.get(12)));
		
			tornados.add(newTornado);
		}
		
		disasters.add(tornados);
		
	}
	
	/**
	 * This method goes through the vehicle crash data and makes an object for each
	 * one.
	 * 
	 * @param allLines - All of the vehicle crash data
	 */
	private static void makeVehicleCrashObjects(ArrayList<List<String>> allLines) {
		
		ArrayList<Disaster> vehicleCrashes = new ArrayList<>();
		
		// loop through each data entry
		Vehicle_Crash newVehicleCrash;
		for(List<String> vehicleCrash : allLines) {
			newVehicleCrash = new Vehicle_Crash(vehicleCrash.get(0), vehicleCrash.get(1), Integer.parseInt(vehicleCrash.get(2)), Integer.parseInt(vehicleCrash.get(3)), Integer.parseInt(vehicleCrash.get(4)), Integer.parseInt(vehicleCrash.get(5)), vehicleCrash.get(6), Tools.locationBreaker(vehicleCrash.get(7)), vehicleCrash.get(8), vehicleCrash.get(9));
		
			vehicleCrashes.add(newVehicleCrash);
		}
		
		disasters.add(vehicleCrashes);
		
	}
	
	/**
	 * This method reads through the campaign file and makes campaign objects for
	 * each data entry in the file.
	 */
	private static void readCampFile() {
		
		// the list of each line of the .csv file
		ArrayList<List<String>> allLines = CSV_Reader.read(CAMPAIGN_DATA);
		
		allLines.remove(0); // get rid of the header row
		
		// loop through each data entry
		Campaign newCampaign;
		for(List<String> campaign : allLines) {
			newCampaign = new Campaign(campaign.get(0), campaign.get(1), campaign.get(2), campaign.get(3), campaign.get(4));
		
			campaigns.add(newCampaign);
		}
		
	}
	
	/**
	 * This method reads through the item file and makes item objects for each data
	 * entry in the file.
	 */
	private static void readItemFile() {
		
		// the list of each line of the .csv file
		ArrayList<List<String>> allLines = CSV_Reader.read(ITEM_DATA);
		
		allLines.remove(0); // get rid of the header row
		
		// loop through each data entry
		Item newItem;
		for(List<String> item : allLines) {
			newItem = new Item(item.get(0), item.get(1), item.get(2));
		
			items.add(newItem);
		}
		
	}
	
	/**
	 * This method reads through the supply item file and makes supply item objects
	 * for each data entry in the file.
	 */
	private static void readSupplyFile() {
		
		// the list of each line of the .csv file
		ArrayList<List<String>> allLines = CSV_Reader.read(SUPPLY_DATA);
		
		allLines.remove(0); // get rid of the header row
		
		// loop through each data entry
		SupplyItem newSupplyItem;
		for(List<String> supplyItem : allLines) {
			newSupplyItem = new SupplyItem(supplyItem.get(0), supplyItem.get(1), supplyItem.get(2), Integer.parseInt(supplyItem.get(3)), supplyItem.get(4));
		
			supplyItems.add(newSupplyItem);
		}
		
	}
	
	/**
	 * This method reads through the agency file and makes agency objects for each
	 * data entry in the file.
	 */
	private static void readAgencyFile() {
		
		// the list of each line of the .csv file
		ArrayList<List<String>> allLines = CSV_Reader.read(AGENCY_DATA);
		
		allLines.remove(0); // get rid of the header row
		
		// loop through each data entry
		Agency newAgency;
		for(List<String> agency : allLines) {
			newAgency = new Agency(agency.get(0), agency.get(1), Integer.parseInt(agency.get(2)), Tools.parseBoolean(agency.get(3)), Tools.parseBoolean(agency.get(4)));
		
			agencies.add(newAgency);
		}
		
	}
	
	/**
	 * This method reads through the agency file and makes agency objects for each
	 * data entry in the file.
	 */
	private static void readCityFile() {
		
		// the list of each line of the .csv file
		ArrayList<List<String>> allLines = CSV_Reader.read(CITY_DATA);
		
		allLines.remove(0); // get rid of the header row
		
		// loop through each data entry
		Location newLocation;
		for(List<String> location : allLines) {
			newLocation = new Location(location.get(0), location.get(1), Integer.parseInt(location.get(2)), Double.parseDouble(location.get(3)), Double.parseDouble(location.get(4)), Double.parseDouble(location.get(5)), Double.parseDouble(location.get(6)));
		
			// add the location to the array list based on country
			boolean added = false;
			for(ArrayList<Location> countryGroup : locations) {
				if(countryGroup.get(0).getCountry().equals(location.get(1))) {
					countryGroup.add(newLocation);
					added = true;
					break;
				}
			}
			if(!added) {
				ArrayList<Location> temp = new ArrayList<>();
				temp.add(newLocation);
				locations.add(temp);
			}
		}
		
	}
	
	/**
	 * This method creates the csv files.
	 */
	private static void genCSVFiles() {
		
		genDisFile();
		
		genDisPathFile();
		
		genExactLocFile();
		
		genImpactReportFile();
		
		genItemsSuppliedFile();
		
		genLocPopFile();
		
		genRelAgencyFile();
		
		genRelCampaignFile();
		
		genRelItemFile();
		
	}

	/**
	 * This method generates the Disaster table.
	 */
	private static void genDisFile() {
		
		// The first row in the csv file
		String header = "ID,type,start_time,end_time,time_of_warning,wind_speed,rainfall,flood_depth,magnitude,cause\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through each disaster type
		for(ArrayList<Disaster> disType : disasters) {
			String id = disType.get(0).getId();
			
			if(id.contains(HURRICANE)) {
				allData += Tools.genDisFile_Hurricane(disType);
			} else if(id.contains(PLANE_CRASH)) {
				allData += Tools.genDisFile_PlaneCrash(disType);
			} else if(id.contains(TORNADO)) {
				allData += Tools.genDisFile_Tornado(disType);
			} else if(id.contains(VEHICLE_CRASH)) {
				allData += Tools.genDisFile_VehicleCrash(disType);
			} else {
				throw new IllegalArgumentException("ERROR: \"" + id + "\" is not recognized as a real disaster ID!");
			}
		}
		
		Tools.writeLocFile(allData, DISASTER);
		
	}

	/**
	 * This method generates the DisasterPath table.
	 */
	private static void genDisPathFile() {
		
		// The first row in the csv file
		String header = "disaster_ID,latitude,longitude,order\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through each disaster type
		for(ArrayList<Disaster> disType : disasters) {
			
			// loop through each disaster
			for(Disaster disaster : disType) {
				int order = 1;
				
				for(double[] location : disaster.getPath()) {
					allData += "" + disaster.getId() + "," + location[0] + "," + location[1] + "," + order + "\n";
					
					order++;
				}
			}
		}
		
		Tools.writeLocFile(allData, DISASTER_PATH);
		
	}

	/**
	 * This method generates the ExactLocation table.
	 */
	private static void genExactLocFile() {
		
		// The first row in the csv file
		String header = "latitude,longitude,city,state\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through each disaster type
		for(ArrayList<Disaster> disType : disasters) {
			
			// loop through each disaster
			for(Disaster disaster : disType) {
				for(double[] location : disaster.getPath()) {
					
					// this is for when location is working right
					String country = Country_Boundries.getCountry(location);
					String city = getCity(location, country);
					
					// This is for when location is being buggy
//					String city = getCity(location);
//					String country = getCountry(city);
					
					allData += "" + location[0] + "," + location[1] + "," + city + "," + country + "\n";
				}
			}
		}
		
		Tools.writeLocFile(allData, EXACT_LOCATION);
		
	}

	/**
	 * This method generates the ImpactReport table.
	 */
	private static void genImpactReportFile() {
		
		// The first row in the csv file
		String header = "report_ID,buildings_destroyed,casualties,permanent_injuries,temporary_injuries,disaster_ID\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through each disaster type
		for(ArrayList<Disaster> disType : disasters) {
			
			// loop through each disaster
			for(Disaster disaster : disType) {
				
				// the first part of the ID which tells what type of disaster it is
				String typePrefix = disaster.getId().substring(0, disaster.getId().indexOf('-')+1);
				
				// create a disaster report id
				String reportID = disaster.getId().replace(typePrefix, "R-"); // FIXME Warning: this will create overlaps if there are one-million of a certain disaster type

				allData += "" + reportID + ",";
				if(typePrefix.equals(HURRICANE)) {
					allData += Tools.genImpactReportFile_Hurricane(disaster);
				} else if(typePrefix.equals(TORNADO)) {
					allData += Tools.genImpactReportFile_Tornado(disaster);
				} else if(typePrefix.equals(PLANE_CRASH) || typePrefix.equals(VEHICLE_CRASH)) {
					allData += "null";
				} else {
					throw new IllegalStateException("ERROR: \"" + typePrefix + "\" is not a proper disaster id prefix!");
				}
				allData += "," + disaster.getDeaths() + "," + disaster.getPermInjuries() + "," + disaster.getTempInjuries() + "," + disaster.getId() + "\n";
			}
		}
		
		Tools.writeLocFile(allData, IMPACT_REPORT);
		
	}

	/**
	 * This method generates the ItemsSupplied table.
	 */
	private static void genItemsSuppliedFile() {
		
		// The first row in the csv file
		String header = "campaign_ID,item_ID,quantity\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through all of the items that were supplied by a relief campaign
		for(SupplyItem supplyItem : supplyItems) {
			allData += "" + supplyItem.getCampaign_ID() + "," + supplyItem.getItem_ID() + "," + supplyItem.getQuantity() + "\n";
		}
		
		Tools.writeLocFile(allData, ITEMS_SUPPLIED);
		
	}

	/**
	 * This method generates the LocationPopulation table.
	 */
	private static void genLocPopFile() {
		
		// The first row in the csv file
		String header = "city,state,population_size\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through each country group
		for(ArrayList<Location> countryGroup : locations) {
			
			// loop through each city
			for(Location location : countryGroup) {
				allData += "" + location.getCity() + "," + location.getCountry() + "," + location.getPopulation() + "\n";
			}
		}
		
		Tools.writeLocFile(allData, LOCATION_POPULATION);
		
	}

	/**
	 * This method generates the ReliefAgency table.
	 */
	private static void genRelAgencyFile() {
		
		// The first row in the csv file
		String header = "agency_ID,name,founded,for_profit,government_run\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through all of the relief agencies
		for(Agency agency : agencies) {
			allData += "" + agency.getID() + "," + agency.getName() + "," + agency.getFounded() + "," + agency.isForProfit() + "," + agency.isGovRun() + "\n";
		}
		
		Tools.writeLocFile(allData, RELIEF_AGENCY);
		
	}

	/**
	 * This method generates the ReliefCampaign table.
	 */
	private static void genRelCampaignFile() {
		
		// The first row in the csv file
		String header = "campaign_ID,start_date,end_date,agency_ID,disaster_ID\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through all of the relief campaigns
		for(Campaign campaign : campaigns) {
			allData += "" + campaign.getCampaign_ID() + "," + campaign.getStartTime() + "," + campaign.getEndTime() + "," + campaign.getAgency_ID() + "," + campaign.getDisaster_ID() + "\n";
		}
		
		Tools.writeLocFile(allData, RELIEF_CAMPAIGN);
		
	}

	/**
	 * This method generates the ReliefItem table.
	 */
	private static void genRelItemFile() {
		
		// The first row in the csv file
		String header = "item_ID,name,cost_per_unit\n";
		
		// all of the rows in the csv file
		String allData = header;
		
		// loop through all of the items
		for(Item item : items) {
			allData += "" + item.getID() + "," + item.getName() + "," + item.getPrice() + "\n";
		}
		
		Tools.writeLocFile(allData, RELIEF_ITEM);
		
	}
	
	/**
	 * This method takes a coordinate pair and finds what city it is in. It also
	 * uses a known country to be more efficient; that way it doesn't have to look
	 * through every city in the database.
	 * 
	 * @param location - coordinate pair - {lat, long}
	 * @param country - the name of the country this city will be in
	 * @return The name of the city where these coordinates can be found.
	 */
	private static String getCity(double[] location, String country) {
		
		// get the list of cities in the country we need
		ArrayList<Location> cities = null;
		for(ArrayList<Location> countryGroup : locations) {
			if(country.equals(countryGroup.get(0).getCountry())) {
				cities = countryGroup;
			}
		}
		if(cities == null) { // error checking
			throw new IllegalStateException("ERROR: \"" + country + "\" is not a country in the locations list!");
		}
		
		double locLat = location[0];
		double locLong = location[1];
		
		for(Location city : cities) {
			double minLat = city.getMinLat();
			double maxLat = city.getMaxLat();
			double minLong = city.getMinLong();
			double maxLong = city.getMaxLong();
			
			if(locLat > minLat && locLat < maxLat) {
				if(locLong > minLong && locLong < maxLong) {
					return city.getCity();
				}
			}
		}
		
		// city not found
		throw new IllegalStateException("ERROR: \"" + locLat + ", " + locLong + "\" not found in any city range!");
		
	}
	
	/**
	 * @deprecated
	 * @see getCity(double[], String)
	 * 
	 * This method takes a coordinate pair and finds what city it is in.
	 * 
	 * @param location - coordinate pair - {lat, long}
	 * @return The name of the city where these coordinates can be found.
	 */
	@Deprecated
	private static String getCity(double[] location) {
		
		double locLat = location[0];
		double locLong = location[1];
		
		// loop through each location
		for(ArrayList<Location> countryGroup : locations) {
			for(Location city : countryGroup) {
				double minLat = city.getMinLat();
				double maxLat = city.getMaxLat();
				double minLong = city.getMinLong();
				double maxLong = city.getMaxLong();
				
				if(locLat > minLat && locLat < maxLat) {
					if(locLong > minLong && locLong < maxLong) {
						return city.getCity();
					}
				}
			}
		}

		// city not found
		throw new IllegalStateException("ERROR: \"" + locLat + ", " + locLong + "\" not found in any city range!");
		
	}
	
	/**
	 * This method searches the locations to find what country a certain city is in.
	 * 
	 * @param city - The name of they city who's country we are looking for
	 * @return The name of the country where these coordinates can be found.
	 */
	public static String getCountry(String city) {
		
		// loop through each location
		for(ArrayList<Location> countryGroup : locations) {
			for(Location location : countryGroup) {
				if(city.equals(location.getCity())) {
					return location.getCountry();
				}
			}
		}
		
		// see if a country was found for the location
		throw new IllegalStateException("ERROR: \"" + city + "\" was not found in any country!");
		
	}

}
